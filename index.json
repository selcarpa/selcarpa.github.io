[{"categories":["tools"],"content":" 背景 我们需要一个统计工具，用于统计静态网页的访问量 不少人的浏览器会安装ublock、adblock等插件，导致一众统计服务无法统计到访问量 ","date":"2023-12-25","objectID":"/docs/tools/plausible/:0:0","series":null,"tags":["web analytics","tools"],"title":"自托管Plausible统计静态网页访问","uri":"/docs/tools/plausible/#背景"},{"categories":["tools"],"content":" PlausiblePlausible是一个开源的统计工具，可以用于统计静态网页的访问量，它的特点是： 基于AGPLv3协议开源 不使用cookie，不追踪用户，不收集个人信息 脚本体积小，不影响网页加载速度 支持公开统计数据 支持邮件订阅统计数据 本文基于docker-compose部署Plausible，使用的是官方提供的docker镜像，部署中去除了email相关的内容。 ","date":"2023-12-25","objectID":"/docs/tools/plausible/:0:0","series":null,"tags":["web analytics","tools"],"title":"自托管Plausible统计静态网页访问","uri":"/docs/tools/plausible/#plausible"},{"categories":["tools"],"content":" 环境要求 docker-compose：安装参考官方文档 ","date":"2023-12-25","objectID":"/docs/tools/plausible/:0:0","series":null,"tags":["web analytics","tools"],"title":"自托管Plausible统计静态网页访问","uri":"/docs/tools/plausible/#环境要求"},{"categories":["tools"],"content":" 部署教程 git clone https://github.com/plausible/hosting cd hosting #编辑docker-compose.yml文件 vim docker-compose.yml ","date":"2023-12-25","objectID":"/docs/tools/plausible/:0:0","series":null,"tags":["web analytics","tools"],"title":"自托管Plausible统计静态网页访问","uri":"/docs/tools/plausible/#部署教程"},{"categories":["tools"],"content":" 配置文件 version: \"3.3\" services: # 可去除邮件相关内容 # mail: # image: bytemark/smtp # restart: always plausible_db: # supported versions are 12, 13, and 14 image: postgres:14-alpine restart: always volumes: - db-data:/var/lib/postgresql/data environment: - POSTGRES_PASSWORD=postgres plausible_events_db: image: clickhouse/clickhouse-server:23.3.7.5-alpine restart: always volumes: - event-data:/var/lib/clickhouse - ./clickhouse/clickhouse-config.xml:/etc/clickhouse-server/config.d/logging.xml:ro - ./clickhouse/clickhouse-user-config.xml:/etc/clickhouse-server/users.d/logging.xml:ro ulimits: nofile: soft: 262144 hard: 262144 plausible: image: plausible/analytics:v2.0 restart: always command: sh -c \"sleep 10 \u0026\u0026 /entrypoint.sh db createdb \u0026\u0026 /entrypoint.sh db migrate \u0026\u0026 /entrypoint.sh run\" depends_on: - plausible_db - plausible_events_db # 可去除邮件相关内容 # - mail ports: - 8000:8000 env_file: - plausible-conf.env volumes: db-data: driver: local event-data: driver: local 执行docker-compose up -d启动服务，启动后访问http://localhost:8000即可看到Plausible的界面。 进行账号注册 新建站点 拷贝站点js 在需要统计的静态网页中添加这段js即可,在后续的访问中，即可看到统计数据 ","date":"2023-12-25","objectID":"/docs/tools/plausible/:1:0","series":null,"tags":["web analytics","tools"],"title":"自托管Plausible统计静态网页访问","uri":"/docs/tools/plausible/#配置文件"},{"categories":["docs"],"content":" 介绍在进行kotlin-native开发时，由于当前版本缺少很多库，所以我们需要使用C/C++进行补充。本文将以linux平台为例，介绍如何在kotlin-native中使用C/C++。 ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:0:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#介绍"},{"categories":["docs"],"content":" 准备工作 idea-community jdk17 cmake linux ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:0:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#准备工作"},{"categories":["docs"],"content":" 参考Interoperability with C Create an app using C Interop and libcurl – tutorial ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:0:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#参考"},{"categories":["docs"],"content":" 项目地址selcarpa/c_link_demo ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:0:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#项目地址"},{"categories":["docs"],"content":" 项目结构 └── c_link_demo ├── c_link_demo_c │ ├── CMakeLists.txt │ ├── library.c │ └── library.h └── c_link_demo_kt ├── build.gradle.kts ├── gradle │ └── wrapper │ ├── gradle-wrapper.jar │ └── gradle-wrapper.properties ├── gradle.properties ├── gradlew ├── gradlew.bat ├── settings.gradle.kts └── src ├── commonMain │ ├── kotlin │ │ └── Main.kt │ └── resources └── nativeInterop └── cinterop └── c_lib_demo.def ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:0:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#项目结构"},{"categories":["docs"],"content":" 步骤","date":"2023-12-06","objectID":"/docs/kt/kt-c/:0:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#步骤"},{"categories":["docs"],"content":" 创建C/C++库此处以C库为例 ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:1:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#创建cc库"},{"categories":["docs"],"content":" 创建C库在c_link_demo_c目录下创建library.c和library.h文件，文件分别声明和实现一个hello函数。 library.h #ifndef C_LIB_DEMO_LIBRARY_H #define C_LIB_DEMO_LIBRARY_H void hello(void); #endif //C_LIB_DEMO_LIBRARY_H library.c #include \"library.h\" #include \u003cstdio.h\u003e void hello(void) { printf(\"Hello, World!\\n\"); } 创建CMakeLists.txt文件，作用是将C库编译成静态库，内容如下： cmake_minimum_required(VERSION 3.27) project(c_link_demo_c C) set(CMAKE_C_STANDARD 11) add_library(c_link_demo_c STATIC library.c) ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:1:1","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#创建c库"},{"categories":["docs"],"content":" 创建kotlin-native项目使用idea创建普通的kotlin(gradle)项目，然后打开项目根目录下的build.gradle.kts文件，更改为以下内容： import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTarget //使用kotlin-multiplatform插件，用以创建native项目 plugins { kotlin(\"multiplatform\") version \"1.9.21\" } //包名版本号 group = \"one.tain\" version = \"1.0-SNAPSHOT\" repositories { mavenCentral() google() } //kotlin插件 kotlin { //指定main函数入口 fun KotlinNativeTarget.config() { binaries { executable { entryPoint = \"main\" } } } //指定平台 linuxX64(\"linuxX64\") { config() } } 可以关注到当前创建了一个kotlin-native的项目，进行一次构建后，会发现idea不会识别main目录下的kotlin文件，native项目的默认源码和资源目录是src/nativeMain/kotlin和src/nativeMain/resources，所以我们需要更改一下项目结构。 在项目根目录下创建src/commonMain/kotlin目录，将main目录下的kotlin文件移动到commonMain目录下，在commonMain目录下创建resources目录，删除main目录。 然后可以调试kotlin原生应用。但是此处并没有进行C的交互链接，后续的步骤会进行C交互的补充。 ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:2:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#创建kotlin-native项目"},{"categories":["docs"],"content":" 创建C/C++交互配置文件在项目根目录下创建nativeInterop/cinterop/c_lib_demo.def文件，内容如下： # 指定头文件的绝对路径 headers = /home/sel/repository/selcarpa/c_link_demo/c_link_demo_c/library.h # 指定库文件的名称 staticLibraries = libc_link_demo_c.a # 指定库文件的绝对路径 libraryPaths = /home/sel/repository/selcarpa/c_link_demo/c_link_demo_c/cmake-build-debug ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:3:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#创建cc交互配置文件"},{"categories":["docs"],"content":" 更改构建脚本在项目根目录下的build.gradle.kts文件中的linuxX64方法下，添加以下内容： compilations[\"main\"].cinterops { @Suppress(\"LocalVariableName\") val c_lib_demo by creating } 点击构建按钮，在idea的External Libraries中可以看到c_lib_demo的库文件已经被加载进来了。 ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:4:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#更改构建脚本"},{"categories":["docs"],"content":" 调用C函数在commonMain目录下的main.kt文件中调用C函数，内容如下： import c_lib_demo.hello import kotlinx.cinterop.ExperimentalForeignApi @OptIn(ExperimentalForeignApi::class) fun main(args: Array\u003cString\u003e) { hello() } 输出结果如下： ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:5:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#调用c函数"},{"categories":["docs"],"content":" 补充说明c_lib_demo.def还有其他的配置方法，例： # 指定头文件的名称 headers = library.h # 指定编译的include行为，从而指定头文件的搜索路径 compilerOpts.linux = -I/home/sel/repository/selcarpa/c_link_demo/c_link_demo_c # 指定链接的行为，从而指定库文件的搜索路径和库文件的名称 linkerOpts.linux = -L/home/sel/repository/selcarpa/c_link_demo/c_link_demo_c/cmake-build-debug -lc_link_demo_c 这种方式更方便地指定不同平台的行为 ","date":"2023-12-06","objectID":"/docs/kt/kt-c/:6:0","series":null,"tags":["kotlin","kotlin-native"],"title":"kotlin-native与C/C++交互","uri":"/docs/kt/kt-c/#补充说明"},{"categories":["tools"],"content":" 介绍在家里搭建一些私有服务时，如果没有公网ip，就无法通过外网访问。这个时候我们一般有三个方案： 方案一，打电话让运营商分配一个公网ip 方案二，使用ipv6 方案三，使用内网穿刺 本文不涉及内网穿刺服务。所以方案三在本文没有任何剩下的讨论内容。 方案一和方案二涉及一个问题，就是公网ip的变化。如果公网ip变化了，就无法通过原有的ip访问到服务。这个时候我们就需要动态的更新域名解析。这个过程就叫做ddns。 ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:1:0","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#介绍"},{"categories":["tools"],"content":" 准备操作","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:0","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#准备操作"},{"categories":["tools"],"content":" 1. 注册cloudflare账号本文不会详细将这个，请参考其他教程。 ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:1","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#1-注册cloudflare账号"},{"categories":["tools"],"content":" 2. 获取cloudflare的api key 访问https://dash.cloudflare.com/profile/api-tokens，右上角处可以切换为简体中文 点击创建令牌，选择编辑区域DNS模板 名称任意填写 令牌权限选择编辑区域DNS，令牌的权限务必选择 区域-区域-读取 区域-dns-编辑 区域资源，选择需要用于ddns的域名 客户端IP（可选），这个用于区别调用客户端的白名单，由于本文讲解ddns，本身访问的公网IP就是动态的，所以这里最好不要填写 TTL，定义此令牌将保持活动状态的时间长度。这个不需要填写 创建令牌 完成后点击创建令牌，并拷贝token 拷贝token ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:2","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#2-获取cloudflare的api-key"},{"categories":["tools"],"content":" 3. 获取zone id 访问https://dash.cloudflare.com/ 选择需要用于ddns的域名 页面右下角即可看到zone id 获取zone id ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:3","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#3-获取zone-id"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#4-配置客户端jvm版本"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#java安装"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#下载jar包"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#配置文件"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#运行jar包"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#直接运行"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#也可配合systemd使用尚未验证"},{"categories":["tools"],"content":" 4. 配置客户端（JVM版本）本文当前版本采用cloudflare-ddns项目作为ddns客户端，项目基于kotlin开发，当前仅提供jar版本，后续会提供native版本。 Java安装本项目采用jdk17作为目标环境，所以需要安装jdk17，此处不会详细介绍。 下载jar包访问cloudflare-ddns的release页面下载最新的jar包到本地任意位置 配置文件在jar包同级目录下创建config.json5文件，内容如下： { \"common\": { \"zoneId\": \"\",//填入上面的zone id \"authKey\": \"\",//填入上面的token \"v4\": false,//是否更新ipv4 \"v6\": false,//是否更新ipv6 \"ttl\": 300//ttl，同时用于缓存时间和dns记录检测的间隔 }, \"domains\": [ { \"name\": \"cd1.tain.one\",//用于ddns的域名 \"proxied\": true//是否开启cloudflare的代理 } ] } 运行jar包 直接运行 java -jar cloudflare-ddns-0.0.1.jar -c=config.json5 直接运行的方式可以使用nohup/tmux/screen等方式后台运行 也可配合systemd使用（尚未验证） #创建服务 vim /etc/systemd/system/cloudflare-ddns.service [Unit] Description=cloudflare-ddns After=network.target [Service] Type=simple ExecStart=/usr/bin/java -jar /opt/cloudflare-ddns-0.0.1.jar -c=/opt/config.json5 Restart=on-failure [Install] WantedBy=multi-user.target #启动服务 systemctl start cloudflare-ddns #设置开机启动 systemctl enable cloudflare-ddns 4. 配置客户端（原生版本）当前原生版本仅支持linux x64，后续会提供更多平台的支持。 （建设中… ","date":"2023-09-11","objectID":"/docs/tools/cf-ddns/:2:4","series":null,"tags":["ddns","cloudflare","cloudflare-ddns"],"title":"使用cloudflare的api实现ddns","uri":"/docs/tools/cf-ddns/#4-配置客户端原生版本"},{"categories":["tools"],"content":" 缘由大部分Java程序员都会使用idea在Windows下进行开发，然后部署到Linux服务器上，大部分情况下，Java强大的跨平台性使得这种方式没有问题。但是！在某些时候，开发使用到的平台api会出现一些问题，导致跨平台很麻烦，比如selenium相关开发，需要用到selenium组件，此组件需要配置一些运行环境，为了避免运行环境差异导致的额外调试。 ","date":"2023-08-29","objectID":"/docs/tools/wslg/:0:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#缘由"},{"categories":["tools"],"content":" 环境要求 Windows 11 WSL2 Ubuntu 22.04 ","date":"2023-08-29","objectID":"/docs/tools/wslg/:0:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#环境要求"},{"categories":["tools"],"content":" 安装wslg运行环境按照微软官方的教程，我们需要安装wslg的环境 ","date":"2023-08-29","objectID":"/docs/tools/wslg/:0:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#安装wslg运行环境"},{"categories":["tools"],"content":" 首先更新软件源 sudo apt update sudo apt upgrade -y ","date":"2023-08-29","objectID":"/docs/tools/wslg/:1:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#首先更新软件源"},{"categories":["tools"],"content":" 安装依赖更新完成软件源后，我们仍然不能直接启动图形软件，需要安装XWayland相关的依赖，按照教程，我们直接安装一个vlc即可 sudo apt install vlc -y ","date":"2023-08-29","objectID":"/docs/tools/wslg/:2:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#安装依赖"},{"categories":["tools"],"content":" 下载toolbox Linux并解压在下载页面选择Linux版本下载，下载完成后解压 wget https://download.jetbrains.com/toolbox/jetbrains-toolbox-2.1.0.18144.tar.gz tar -zxvf jetbrains-toolbox-2.1.0.18144.tar.gz ","date":"2023-08-29","objectID":"/docs/tools/wslg/:0:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#下载toolbox-linux并解压"},{"categories":["tools"],"content":" 安装AppImage运行环境参考 #ubuntu22.04安装方式 sudo add-apt-repository universe sudo apt install libfuse2 ","date":"2023-08-29","objectID":"/docs/tools/wslg/:0:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#安装appimage运行环境"},{"categories":["tools"],"content":" 运行toolbox ./jetbrains-toolbox-2.1.0.18144/jetbrains-toolbox ","date":"2023-08-29","objectID":"/docs/tools/wslg/:0:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#运行toolbox"},{"categories":["tools"],"content":" 安装idea点击intellij idea community，然后点击install即可 另外，其他一些Jetbrains的IDE也可以使用这种方式安装 ","date":"2023-08-29","objectID":"/docs/tools/wslg/:0:0","series":null,"tags":["wsl","wslg","Jetbrains"],"title":"借助wslg使用Linux版本的idea","uri":"/docs/tools/wslg/#安装idea"},{"categories":["docs"],"content":" 用Netty实现Trojan（二）本节主要是介绍如何实现一个允许tcp通过的socks代理服务器，大部分携带网络功能的客户端，如curl、wget、浏览器等，在请求的时候，可以通过环境变量或者设置的形式，使这些客户端通过代理进行请求，以下是一个简单的例子： export https_proxy=socks5://127.0.0.1:1080 # 设置https使用socks5代理 curl -v https://www.google.com # 进行一次https的请求 在实现trojan协议之前，我们首先需要实现一个socks5代理服务端，用以在客户端中使用。 本文目前参照Netty官方的socks5实现，实现了一个socks代理服务器，由于大部分客户端都已经同时兼容socks4和socks5，此处仅实现socks5协议，socks5协议支持tcp、udp连接方式，但此处只实现了socks5的tcp代理。 ","date":"2023-08-25","objectID":"/docs/surfer2/:0:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#用netty实现trojan二"},{"categories":["docs"],"content":" 参考 Netty/Netty socks example socks wiki ","date":"2023-08-25","objectID":"/docs/surfer2/:1:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#参考"},{"categories":["docs"],"content":" 时序图socks5的tcp代理，大致时序如下： sequenceDiagram autonumber participant 客户端 participant 代理服务器 participant 目标服务器 客户端 --\u003e 代理服务器: 建立Tcp连接 客户端 -\u003e\u003e+ 代理服务器: 发送socks5的初始化请求 代理服务器 -\u003e\u003e- 客户端: 发送socks5的初始化响应 alt 无密码认证 客户端 --\u003e 代理服务器: 建立socks5连接 else 需要密码认证 critical 密码认证 客户端 -\u003e\u003e+ 代理服务器: 发送密码认证请求 代理服务器 -\u003e\u003e- 客户端: 验证密码，发送结果 option 密码错误 客户端 --\u003e 客户端: 结束 option 密码正确 客户端 --\u003e 代理服务器: 建立socks5连接 end end 代理服务器 -\u003e\u003e 目标服务器: 建立tcp连接 代理服务器 -\u003e\u003e 客户端: 发送socks5连接响应 loop 后续的交互 客户端 -\u003e\u003e+ 代理服务器: 发送请求报文 代理服务器 -\u003e\u003e+ 目标服务器: 转发请求报文 目标服务器 -\u003e\u003e- 代理服务器: 发送响应报文 代理服务器 -\u003e\u003e- 客户端: 转发响应报文 end ","date":"2023-08-25","objectID":"/docs/surfer2/:2:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#时序图"},{"categories":["docs"],"content":" 实现","date":"2023-08-25","objectID":"/docs/surfer2/:3:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#实现"},{"categories":["docs"],"content":" 初始化通道初始化通道采用Netty的SocksPortUnificationServerHandler ，在这个handler中，会将首个请求，按照socks4或者socks5的协议进行解析，解析结果SocksMessage 对象。此段对应上面时序图中建立Tcp连接和发送socks5的初始化请求部分的处理。这部分都是Netty内部的解码器已经实现了，这部分主要是将这部分组合起来，连同Netty自身启动一起介绍。 启动Netty部分 ServerBootstrap().group(bossGroup, workerGroup) .channel(NioServerSocketChannel::class.java) .childHandler(ProxyChannelInitializer()) //此处定义一个通道初始化器，用于后续根据业务逻辑来初始化pipeline等信息 .bind(inbound.port) 通道管线初始化 //... class ProxyChannelInitializer : ChannelInitializer\u003cNioSocketChannel\u003e() { //... override fun initChannel(ch: NioSocketChannel) { //... initSocksInbound(ch, inbound) return //... } private fun initSocksInbound(ch: NioSocketChannel, inbound: Inbound) { ch.pipeline().addLast(SocksPortUnificationServerHandler()) //在此处添加socks协议初始化的协议解析器 //... } //... } ","date":"2023-08-25","objectID":"/docs/surfer2/:3:1","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#初始化通道"},{"categories":["docs"],"content":" 初始化通道初始化通道采用Netty的SocksPortUnificationServerHandler ，在这个handler中，会将首个请求，按照socks4或者socks5的协议进行解析，解析结果SocksMessage 对象。此段对应上面时序图中建立Tcp连接和发送socks5的初始化请求部分的处理。这部分都是Netty内部的解码器已经实现了，这部分主要是将这部分组合起来，连同Netty自身启动一起介绍。 启动Netty部分 ServerBootstrap().group(bossGroup, workerGroup) .channel(NioServerSocketChannel::class.java) .childHandler(ProxyChannelInitializer()) //此处定义一个通道初始化器，用于后续根据业务逻辑来初始化pipeline等信息 .bind(inbound.port) 通道管线初始化 //... class ProxyChannelInitializer : ChannelInitializer() { //... override fun initChannel(ch: NioSocketChannel) { //... initSocksInbound(ch, inbound) return //... } private fun initSocksInbound(ch: NioSocketChannel, inbound: Inbound) { ch.pipeline().addLast(SocksPortUnificationServerHandler()) //在此处添加socks协议初始化的协议解析器 //... } //... } ","date":"2023-08-25","objectID":"/docs/surfer2/:3:1","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#启动netty部分"},{"categories":["docs"],"content":" 初始化通道初始化通道采用Netty的SocksPortUnificationServerHandler ，在这个handler中，会将首个请求，按照socks4或者socks5的协议进行解析，解析结果SocksMessage 对象。此段对应上面时序图中建立Tcp连接和发送socks5的初始化请求部分的处理。这部分都是Netty内部的解码器已经实现了，这部分主要是将这部分组合起来，连同Netty自身启动一起介绍。 启动Netty部分 ServerBootstrap().group(bossGroup, workerGroup) .channel(NioServerSocketChannel::class.java) .childHandler(ProxyChannelInitializer()) //此处定义一个通道初始化器，用于后续根据业务逻辑来初始化pipeline等信息 .bind(inbound.port) 通道管线初始化 //... class ProxyChannelInitializer : ChannelInitializer() { //... override fun initChannel(ch: NioSocketChannel) { //... initSocksInbound(ch, inbound) return //... } private fun initSocksInbound(ch: NioSocketChannel, inbound: Inbound) { ch.pipeline().addLast(SocksPortUnificationServerHandler()) //在此处添加socks协议初始化的协议解析器 //... } //... } ","date":"2023-08-25","objectID":"/docs/surfer2/:3:1","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#通道管线初始化"},{"categories":["docs"],"content":" socks5的认证报文处理由于socks5的认证处理部分是建议自定义的，Netty仅提供了大致的结构实现，具体如何去认证，由开发者自己实现。此处，我们需要实现一个免密认证和账号密码认证。在三一部分的初始化过程中，客户端发送的tcp数据包，已经由SocksPortUnificationServerHandler 转化为SocksMessage对象，此处我们创建一个SimpleChannelInboundHandler的实现类，泛型指定为SocksMessage，用以处理socks5的认证请求。 在认证请求处理完成后，代理服务前会从当前的初始化-认证处理阶段进入到命令报文的处理阶段，此时，我们需要将SocksServerHandler 从pipeline中移除，添加SocksServerConnectHandler，用以处理后续的命令报文。这一段在下文的注释3中有说明。 在认证过程的处理中，我们分两个步骤进行，第一个步骤接受到的是socks5的初始数据包，数据包格式如下： – VER NMETHODS METHODS 字节数 1 1 1~255 VER：socks版本，此处为5（在以下代码注释1中，有用到此信息进行版本判断） NMETHODS：METHODS的长度（这部分是在SocksPortUnificationServerHandler已经自动处理） METHODS：METHODS的内容，METHODS的内容为1~ 255的数字，代表认证方式，0x00代表无密码认证，0x02代表账号密码认证（在本段代码中，只是想实现这两种认证方式，其他的认证方式，可以参考socks5协议文档自行实现） 服务器从客户端提供的方法中选择一个并通过以下消息通知客户端： – VER METHOD 字节数 1 1 VER：socks版本，此处为5 METHOD：METHODS的内容，其中选一个进行返回，如果没有一个认证方式，可以进行返回0xFF，此处我们只实现了0x00和0x02，所以返回0x00或者0x02（在注释2 处，根据项目配置信息，会选择返回无密码认证或者有密码认证） SOCKS5 用户名密码认证方式 在客户端、服务端协商使用用户名密码认证后，客户端发出用户名密码，格式为 – VER ULEN UNAME PLEN PASSWD 字节数 1 1 1~255 1 1~255 VER：鉴定协议版本目前为 0x01 ULEN：UNAME 长度，1 字节 UNAME：用户名 PLEN：PASSWD 长度，1 字节 PASSWD：密码 服务器鉴定后发出如下回应（）： – VER STATUS 字节数 1 1 VER：鉴定协议版本目前为 0x01 STATUS：鉴定状态，0x00 表示成功，0x01 表示失败。 其中鉴定状态 0x00 表示成功，0x01 表示失败。 class SocksServerHandler(private val inbound: Inbound) : SimpleChannelInboundHandler\u003cSocksMessage\u003e() { //... //用以标记此通道是否已经认证 private var authed = false public override fun channelRead0(ctx: ChannelHandlerContext, socksRequest: SocksMessage) { when (socksRequest.version()!!) {//注释1，此处为socks版本判断 SocksVersion.SOCKS5 -\u003e socks5Connect(ctx, socksRequest) else -\u003e { ctx.close() } } } /** * socks5 connect */ private fun socks5Connect(ctx: ChannelHandlerContext, socksRequest: SocksMessage) { //... when (socksRequest) { is Socks5InitialRequest -\u003e { socks5auth(ctx) } is Socks5PasswordAuthRequest -\u003e { socks5DoAuth(socksRequest, ctx) } is Socks5CommandRequest -\u003e { if (inbound.socks5Setting?.auth != null || !authed) { ctx.close() } if (socksRequest.type() === Socks5CommandType.CONNECT) { //注释3，在客户端直接发送Socks5CommandRequest请求时，已经不需要SocksServerHandler进行处理了，所以需要将SocksServerHandler从pipeline中移除，添加SocksServerConnectHandler ctx.pipeline().addLast(SocksServerConnectHandler(inbound)) ctx.pipeline().remove(this) ctx.fireChannelRead(socksRequest) } else { ctx.close() } } else -\u003e { ctx.close() } } } /** * socks5 auth * 注释2，此处根据配置信息，选择返回无密码认证或者有密码认证 */ private fun socks5auth(ctx: ChannelHandlerContext) { if (inbound.socks5Setting?.auth != null) { ctx.pipeline().addFirst(Socks5PasswordAuthRequestDecoder())//有密码认证的情况下，添加密码认证报文解析器 ctx.write(DefaultSocks5InitialResponse(Socks5AuthMethod.PASSWORD)) //返回有密码认证 } else { authed = true ctx.pipeline() .addFirst(Socks5CommandRequestDecoder())//有密码认证的情况下，添加命令报文的解析器，此解析器将socks5连接过程中的报文解析为Socks5CommandRequest对象 ctx.write(DefaultSocks5InitialResponse(Socks5AuthMethod.NO_AUTH)) //返回无密码认证 } } /** * socks5 auth * 此处进行了密码认证，如果认证失败，则关闭连接 */ private fun socks5DoAuth(socksRequest: Socks5PasswordAuthRequest, ctx: ChannelHandlerContext) { if (inbound.socks5Setting?.auth?.username != socksRequest.username() || inbound.socks5Setting?.auth?.password != socksRequest.password() ) { logger.warn(\"socks5 auth failed from: ${ctx.channel().remoteAddress()}\") ctx.write(DefaultSocks5PasswordAuthResponse(Socks5PasswordAuthStatus.FAILURE)) ctx.close() return } ctx.pipeline().addFirst(Socks5CommandRequestDecoder()) ctx.write(DefaultSocks5PasswordAuthResponse(Socks5PasswordAuthStatus.SUCCESS)) authed = true } //... } ","date":"2023-08-25","objectID":"/docs/surfer2/:3:2","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#socks5的认证报文处理"},{"categories":["docs"],"content":" socks5的命令报文处理认证结束后客户端就可以发送请求信息。如果认证方法有特殊封装要求，请求必须按照方法所定义的方式进行封装。 SOCKS5请求格式： – VER CMD RSV ATYP DST.ADDR DST.PORT 字节数 1 1 1 1 动态 2 VER：SOCKS版本，此处为5 CMD：SOCKS命令码，1 字节，有 3 种命令码： 0x01：CONNECT 命令 0x02：BIND 命令 0x03：UDP ASSOCIATE 命令 RSV：保留字，1 字节，值 0x00 ATYP：地址类型，1 字节，有 3 种类型： 0x01：IPv4 地址 0x03：域名 0x04：IPv6 地址 DST.ADDR：目的地址，长度不定 DST.PORT：目的端口，2 字节 关于sock5命令报文，这里需要抽出其中有用的几个信息，分别是CMD、ATYP、DST.ADDR、DST.PORT，Netty内部提供的Socks5CommandRequest 对象，已经将这些信息抽取出来了，我们只需要从中获取即可。 此处仅探讨CMD=0x01的情况，即CONNECT命令，此命令在socks5协议中，是用来建立tcp连接的，根据Wikipedia对于socks5的介绍，在服务端收到命令报文，且CMD为0x01后，需要根据报文内容，即目标服务前的地址和端口，建立tcp连接，然后返回一个响应报文，响应报文格式如下： – VER REP RSV ATYP BND.ADDR BND.PORT 字节数 1 1 1 1 动态 2 VER：SOCKS版本，此处为5 REP：响应码，1 字节，有 6 种响应码： 0x00：请求成功 0x01：普通 SOCKS 服务器连接失败 0x02：现有规则不允许连接 0x03：网络不可达 0x04：主机不可达 0x05：连接被拒 0x06：TTL 超时 0x07：不支持的命令 0x08：不支持的地址类型 0x09：其它错误 0x0A-0xFF：未定义 RSV：保留字，1 字节，值 0x00 ATYP：地址类型，1 字节，有 3 种类型： 0x01：IPv4 地址 0x03：域名 0x04：IPv6 地址 BND.ADDR：绑定地址，长度不定 BND.PORT：绑定端口，2 字节 class SocksServerConnectHandler(private val inbound: Inbound) : SimpleChannelInboundHandler\u003cSocksMessage\u003e() { //... /** * socks5 command */ private fun socks5Command(originCTX: ChannelHandlerContext, message: Socks5CommandRequest) { //... resolveOutbound.ifPresent { outbound -\u003e relayAndOutbound( RelayAndOutboundOp( originCTX = originCTX, outbound = outbound, odor = odor ).also {relayAndOutboundOp -\u003e relayAndOutboundOp.connectEstablishedCallback = { //此处采用回调的方式，当连接建立成功后，进行回调 originCTX.channel().writeAndFlush( //回调的方法是向客户端发送一个连接成功的响应报文 DefaultSocks5CommandResponse( Socks5CommandStatus.SUCCESS, message.dstAddrType(), message.dstAddr(), message.dstPort() ) ).addListener(ChannelFutureListener { //在响应报文发送完成后，移除SocksServerConnectHandler originCTX.pipeline().remove(this@SocksServerConnectHandler) }) } //... } ) } //... } } 至此，代码就已经能成功处理socks5代理的各种报文，并且建立了到达目标服务前的tcp连接，下一步就是将客户端的请求报文转发到目标服务前，以及将目标服务前的响应报文转发到客户端。 ","date":"2023-08-25","objectID":"/docs/surfer2/:3:3","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#socks5的命令报文处理"},{"categories":["docs"],"content":" 转发报文（中继Handler实现）中继Handler的目标是将一个channel中接收到的报文，转发至另一个channel，实现方式非常简单，我们在构造函数中，将目标channel作为参数传递至handler的实现中，当handler接收到源channel发送的报文，直接调用目标channel的write，将此handler添加到socks5来自客户端的连接和到达目标服务器的连接的最后一项即可，以下是代码实现。 /** * relay from client channel to server */ class RelayInboundHandler(private val relayChannel: Channel, private val inActiveCallBack: () -\u003e Unit = {}) : ChannelInboundHandlerAdapter() { //... override fun channelRead(ctx: ChannelHandlerContext, msg: Any) { if (relayChannel.isActive) { //... relayChannel.writeAndFlush(msg).addListener(ChannelFutureListener { //... }) } else { //... } } //... } ","date":"2023-08-25","objectID":"/docs/surfer2/:3:4","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#转发报文中继handler实现"},{"categories":["docs"],"content":" 总结socks5的代理实现主要是需要根据socks5的报文定义，分别实现初始化报文、认证报文、命令报文的解析，以及根据命令报文的内容，建立到达目标服务前的tcp连接，然后将客户端的请求报文转发到目标服务前，将目标服务前的响应报文转发到客户端。 ","date":"2023-08-25","objectID":"/docs/surfer2/:4:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan","socks"],"title":"用Netty实现Trojan（二）\"","uri":"/docs/surfer2/#总结"},{"categories":["docs"],"content":" 用Netty实现Trojan（一）","date":"2023-08-25","objectID":"/docs/surfer1/:0:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#用netty实现trojan一"},{"categories":["docs"],"content":" 完整代码selcarpa/surfer tag(1.13-SHAPSHOT) ","date":"2023-08-25","objectID":"/docs/surfer1/:1:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#完整代码"},{"categories":["docs"],"content":" 选用技术栈 kotlin Netty Trojan ","date":"2023-08-25","objectID":"/docs/surfer1/:2:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#选用技术栈"},{"categories":["docs"],"content":" 介绍","date":"2023-08-25","objectID":"/docs/surfer1/:3:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#介绍"},{"categories":["docs"],"content":" Kotlin项目采用kotlin语言，它是一种基于JVM的静态类型编程语言，它可以编译成Java字节码，完全兼容Java的生态系统，可以与Java代码无缝互操作。它的语法与Java非常相似，但是它有更多的特性，比如：null安全、扩展函数、运算符重载、lambda表达式、属性代理等等。 ","date":"2023-08-25","objectID":"/docs/surfer1/:3:1","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#kotlin"},{"categories":["docs"],"content":" NettyNetty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty是一个NIO客户端-服务器框架，使用Netty可以快速开发网络应用，例如服务器和客户端协议。Netty提供了一种新的方式来使开发网络应用程序，这种新的方式使得它很容易使用和有很强的扩展性。 ","date":"2023-08-25","objectID":"/docs/surfer1/:3:2","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#netty"},{"categories":["docs"],"content":" 什么是TrojanTrojan协议是一个类似于socks的代理协议，它的特点是可以在tls的连接中传输，这样就可以在网络中隐藏自己的流量，使得流量看起来像是一个正常的https连接，从而规避流量审查，在认证方式上，trojan采用56字节作为认证字段，用以验证客户端和服务端的身份。在交互报文中，Trojan协议的Trojan request结构与socks5的socks5 CMD几乎一样。 早期，Trojan协议被设计为监听443端口，在进行ssl认证之后，进行tcp的协议交互。从Trojan on v2ray开始，Trojan协议可以用于在任何流上进行传输，在我的一些代理的配置中，多使用tls+ws+trojan的方式进行传输，在这种方式下，Trojan协议的内容依照原本的http协议流量进行发送，既能有效隐藏流量特征，又能借助一些cdn服务，使用更优质的线路。 ","date":"2023-08-25","objectID":"/docs/surfer1/:3:3","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#什么是trojan"},{"categories":["docs"],"content":" 思路Netty作为Java网络编程的重要框架，可以很好的实现tcp/udp等协议的接收与发送，在本文中，将介绍如何使用Netty去实现trojan协议，兼容v2fly中的tls+ws+trojan的配置方式。那么如何实现这一形式的协议的收发。 在此配置中trojan协议的数据包会作为二进制数据，在websocket的二进制数据帧中进行传输，而websocket的内容会以tcp形式的包，传输在tls的连接之中，对应这部分的传输内容，我们需要实现将trojan协议的包封装为websocket的二进制数据帧，以及将websocket的二进制数据帧解析为trojan协议的包。 ","date":"2023-08-25","objectID":"/docs/surfer1/:4:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#思路"},{"categories":["docs"],"content":" 目标 兼容实现v2fly/v2fly-core的ws+tls+trojan配置方式的客户端及服务端 实现http和socks5入口代理，用以在http或者其他客户端中使用此代理 ","date":"2023-08-25","objectID":"/docs/surfer1/:5:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#目标"},{"categories":["docs"],"content":" 探讨 探讨socks5的udp associate的实现方式 ","date":"2023-08-25","objectID":"/docs/surfer1/:6:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#探讨"},{"categories":["docs"],"content":" 全文说明本文基于curl作为访问客户端进行测试，使用方式如下 export http_proxy=http://127.0.0.1:14271 # 设置http的环境变量 export https_proxy=http://127.0.0.1:14271 # 设置https的环境变量 curl -v http://www.google.com # 进行一次http的请求 curl -v https://www.google.com # 进行一次https的请求 ","date":"2023-08-25","objectID":"/docs/surfer1/:7:0","series":null,"tags":["Netty","java","kotlin","surfer","trojan"],"title":"用Netty实现Trojan（一）","uri":"/docs/surfer1/#全文说明"}]